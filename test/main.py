# Generated by ChatGPT
import smtplib
import ssl
import unittest
import socket

class TestMMailServer(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Configuration matches your server defaults
        cls.host = "localhost"
        cls.port = 25
        cls.sender = "test@example.com"
        cls.receiver = "admin@e45g.org"

        # SSL context for self-signed certificates
        cls.context = ssl.create_default_context()
        cls.context.check_hostname = False
        cls.context.verify_mode = ssl.CERT_NONE

    def test_01_basic_plain_delivery(self):
        """Test sending a standard email without TLS."""
        with smtplib.SMTP(self.host, self.port) as server:
            server.ehlo()
            response = server.sendmail(self.sender, self.receiver, "Subject: Plain Test\n\nHello!")
            self.assertEqual(response, {}) # Empty dict means success

    def test_02_tls_encryption(self):
        """Verify STARTTLS command and encrypted communication."""
        with smtplib.SMTP(self.host, self.port) as server:
            server.ehlo()
            self.assertTrue(server.has_extn("starttls"))
            server.starttls(context=self.context)
            # Re-EHLO is required by SMTP spec after STARTTLS
            status, msg = server.ehlo()
            self.assertEqual(status, 250)
            server.sendmail(self.sender, self.receiver, "Subject: TLS Test\n\nEncrypted!")

    def test_03_state_machine_enforcement(self):
        """Verify the server rejects DATA before RCPT."""
        with smtplib.SMTP(self.host, self.port) as server:
            server.ehlo()
            server.mail(self.sender)
            # Directly attempting DATA without RCPT TO
            status, message = server.docmd("DATA")
            self.assertEqual(status, 503) # 503 Error: need RCPT command

    def test_04_multiple_recipients(self):
        """Verify the server handles up to MAX_REC (10) recipients."""
        recipients = [f"user{i}@e45g.org" for i in range(5)]
        with smtplib.SMTP(self.host, self.port) as server:
            server.ehlo()
            server.mail(self.sender)
            for rcpt in recipients:
                status, msg = server.rcpt(rcpt)
                self.assertEqual(status, 250)

    def test_05_line_too_long(self):
        """Verify server protection against buffer overflows."""
        # BUFFER_SIZE is 1MB, so we send slightly more than that
        large_command = "MAIL FROM:<" + ("a" * 1024 * 1025) + ">"
        with socket.create_connection((self.host, self.port)) as sock:
            sock.recv(1024) # Greeting
            sock.sendall(large_command.encode() + b"\r\n")
            response = sock.recv(1024).decode()
            self.assertIn("500 Line too long", response) #

    def test_06_reset_command(self):
        """Verify RSET clears session state."""
        with smtplib.SMTP(self.host, self.port) as server:
            server.ehlo()
            server.mail(self.sender)
            server.rset() # Should clear sender and recipients
            # If we try DATA now, it should fail as if we just started
            status, _ = server.docmd("DATA")
            self.assertEqual(status, 503)

if __name__ == "__main__":
    unittest.main()
